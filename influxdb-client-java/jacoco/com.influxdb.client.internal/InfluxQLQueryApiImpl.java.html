<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InfluxQLQueryApiImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">The Java InfluxDB 2.x Client</a> &gt; <a href="index.source.html" class="el_package">com.influxdb.client.internal</a> &gt; <span class="el_source">InfluxQLQueryApiImpl.java</span></div><h1>InfluxQLQueryApiImpl.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.influxdb.client.internal;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.influxdb.Cancellable;
import com.influxdb.client.InfluxQLQueryApi;
import com.influxdb.client.domain.InfluxQLQuery;
import com.influxdb.client.service.InfluxQLQueryService;
import com.influxdb.internal.AbstractQueryApi;
import com.influxdb.query.InfluxQLQueryResult;
import com.influxdb.utils.Arguments;

import okhttp3.ResponseBody;
import okio.BufferedSource;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import retrofit2.Call;

public class InfluxQLQueryApiImpl extends AbstractQueryApi implements InfluxQLQueryApi {

    private final InfluxQLQueryService service;

<span class="nc" id="L56">    public InfluxQLQueryApiImpl(@Nonnull final InfluxQLQueryService service) {</span>

<span class="nc" id="L58">        Arguments.checkNotNull(service, &quot;service&quot;);</span>

<span class="nc" id="L60">        this.service = service;</span>
<span class="nc" id="L61">    }</span>

    @Nonnull
    @Override
    public InfluxQLQueryResult query(@Nonnull final InfluxQLQuery influxQlQuery) {
<span class="nc" id="L66">        return query(influxQlQuery, null);</span>
    }

    @Nonnull
    @Override
    public InfluxQLQueryResult query(
            @Nonnull final InfluxQLQuery influxQlQuery,
            @Nullable final InfluxQLQueryResult.Series.ValueExtractor valueExtractor
    ) {
<span class="nc" id="L75">        Call&lt;ResponseBody&gt; call = service.query(</span>
<span class="nc" id="L76">                influxQlQuery.getCommand(),</span>
<span class="nc" id="L77">                influxQlQuery.getDatabase(),</span>
<span class="nc" id="L78">                influxQlQuery.getRetentionPolicy(),</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                influxQlQuery.getPrecision() != null ? influxQlQuery.getPrecision().getSymbol() : null,</span>
                null);

<span class="nc" id="L82">        AtomicReference&lt;InfluxQLQueryResult&gt; atomicReference = new AtomicReference&lt;&gt;();</span>
<span class="nc" id="L83">        BiConsumer&lt;Cancellable, BufferedSource&gt; consumer = (cancellable, bufferedSource) -&gt; {</span>
            try {
<span class="nc" id="L85">                InfluxQLQueryResult result = parseResponse(bufferedSource, cancellable, valueExtractor);</span>
<span class="nc" id="L86">                atomicReference.set(result);</span>
<span class="nc" id="L87">            } catch (IOException e) {</span>
<span class="nc" id="L88">                ERROR_CONSUMER.accept(e);</span>
<span class="nc" id="L89">            }</span>
<span class="nc" id="L90">        };</span>
<span class="nc" id="L91">        query(call, consumer, ERROR_CONSUMER, EMPTY_ACTION, false);</span>
<span class="nc" id="L92">        return atomicReference.get();</span>
    }

    private InfluxQLQueryResult parseResponse(
            @Nonnull final BufferedSource bufferedSource,
            @Nonnull final Cancellable cancellable,
            @Nullable final InfluxQLQueryResult.Series.ValueExtractor valueExtractor) throws IOException {

<span class="nc" id="L100">        Arguments.checkNotNull(bufferedSource, &quot;bufferedSource&quot;);</span>

<span class="nc" id="L102">        try (Reader reader = new InputStreamReader(bufferedSource.inputStream(), StandardCharsets.UTF_8)) {</span>
<span class="nc" id="L103">            return readInfluxQLResult(reader, cancellable, valueExtractor);</span>
        }
    }

    static InfluxQLQueryResult readInfluxQLResult(
            @Nonnull final Reader reader,
            @Nonnull final Cancellable cancellable,
            @Nullable final InfluxQLQueryResult.Series.ValueExtractor valueExtractor
    ) throws IOException {
<span class="fc" id="L112">        List&lt;InfluxQLQueryResult.Result&gt; results = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L114">        Map&lt;String, InfluxQLQueryResult.Series&gt; series = null;</span>
<span class="fc" id="L115">        Map&lt;String, Integer&gt; headerCols = null;</span>
<span class="fc" id="L116">        int nameCol = 0;</span>
        // The first 3 columns are static (`name`, `tags` and `time`) and got skipped.
        // All other columns are dynamically parsed
<span class="fc" id="L119">        int dynamicColumnsStartIndex = 2;</span>

<span class="fc" id="L121">        try (CSVParser parser = new CSVParser(reader, CSVFormat.DEFAULT.builder().setIgnoreEmptyLines(false).build())) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            for (CSVRecord csvRecord : parser) {</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                if (cancellable.isCancelled()) {</span>
<span class="nc" id="L124">                    break;</span>
                }
<span class="fc" id="L126">                int resultIndex = results.size();</span>
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">                if (csvRecord.size() == 1 || csvRecord.get(0).equals(&quot;&quot;)) {</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">                    if (series != null) {</span>
<span class="fc" id="L129">                        InfluxQLQueryResult.Result result = new InfluxQLQueryResult.Result(</span>
                                resultIndex,
<span class="fc" id="L131">                                new ArrayList&lt;&gt;(series.values())</span>
                        );
<span class="fc" id="L133">                        results.add(result);</span>
                    }
<span class="fc" id="L135">                    series = null;</span>
<span class="fc" id="L136">                    continue;</span>
                }

<span class="fc bfc" id="L139" title="All 2 branches covered.">                if (series == null) {</span>

<span class="fc" id="L141">                    List&lt;String&gt; header = csvRecord.toList();</span>
<span class="fc" id="L142">                    headerCols = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                    for (int col = dynamicColumnsStartIndex; col &lt; header.size(); col++) {</span>
<span class="fc" id="L144">                        String colName = header.get(col);</span>
<span class="fc" id="L145">                        headerCols.put(colName, col - dynamicColumnsStartIndex);</span>
                    }
<span class="fc" id="L147">                    series = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L149">                } else {</span>
<span class="fc" id="L150">                    String name = csvRecord.get(nameCol);</span>
<span class="fc" id="L151">                    Map&lt;String, Integer&gt; finalHeaderCols = headerCols;</span>
<span class="fc" id="L152">                    InfluxQLQueryResult.Series serie = series.computeIfAbsent(</span>
                            name,
<span class="fc" id="L154">                            n -&gt; new InfluxQLQueryResult.Series(n, finalHeaderCols)</span>
                    );
<span class="fc" id="L156">                    Object[] values = headerCols.entrySet().stream().map(entry -&gt; {</span>
<span class="fc" id="L157">                        String value = csvRecord.get(entry.getValue() + dynamicColumnsStartIndex);</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                        if (valueExtractor != null) {</span>
<span class="fc" id="L159">                            return valueExtractor.extractValue(entry.getKey(), value, resultIndex, serie.getName());</span>
                        }
<span class="nc" id="L161">                        return value;</span>
<span class="fc" id="L162">                    }).toArray();</span>
<span class="fc" id="L163">                    InfluxQLQueryResult.Series.Record record = serie.new Record(values);</span>
<span class="fc" id="L164">                    serie.addRecord(record);</span>
                }
<span class="fc" id="L166">            }</span>
        }
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (series != null) {</span>
<span class="fc" id="L169">            InfluxQLQueryResult.Result result = new InfluxQLQueryResult.Result(</span>
<span class="fc" id="L170">                    results.size(),</span>
<span class="fc" id="L171">                    new ArrayList&lt;&gt;(series.values())</span>
            );
<span class="fc" id="L173">            results.add(result);</span>
        }
<span class="fc" id="L175">        return new InfluxQLQueryResult(results);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>